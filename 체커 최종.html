<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI와 대결! 체커 게임</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;700;900&display=swap" rel="stylesheet">
    
    <style>
        /* ---------------- CSS (화면 꾸미기) - 수정본 ---------------- */
        
        :root {
            --dark-square: #b8cde0;
            --light-square: #ffffff;
            --player-1: #ff7a7a;
            --player-2: #7a9fff;
            --background: #e0e8f0;
            --text-dark: #2c3e50;  
            
            --highlight-move: rgba(0, 0, 0, 0.3);
            --highlight-p1-glow: rgba(255, 122, 122, 0.7);
            --highlight-p2-glow: rgba(122, 159, 255, 0.7);
        }
        
        body {
            font-family: 'Nunito', 'Malgun Gothic', sans-serif;
            display: flex;
            flex-direction: row; /* 가로로 배치 */
            align-items: flex-start; /* 위쪽 정렬 (게임 컨테이너 기준) */
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            background-color: var(--background);
            color: var(--text-dark);
            text-align: center;
            gap: 40px; /* 게임판과 스코어보드 사이 간격 */
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            margin-bottom: 22px;
            font-weight: 900;
            font-size: 3.3em; /* 큼직한 제목 유지 */
        }

        #status-message {
            font-size: 1.9em; /* 큼직한 상태 메시지 유지 */
            margin-bottom: 22px;
            font-weight: 700;
            height: 1.5em;
            color: var(--text-dark);
        }
        
        /* 4. [수정] 보드판 스타일 (크기 80px로 축소) */
        .board {
            display: grid;
            /* [수정] 칸 크기를 80px로 (90px -> 80px) */
            grid-template-columns: repeat(8, 80px);
            grid-template-rows: repeat(8, 80px);
            border: 5px solid var(--text-dark); /* 파란색 계열 진한 테두리 */
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1), 0 4px 8px rgba(0, 0, 0, 0.05);
            overflow: hidden;
        }

        /* [수정] 칸 크기 80px로 축소 */
        .square {
            width: 80px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            position: relative;
            transition: background-color 0.2s;
        }

        .light {
            background-color: var(--light-square);
        }

        .dark {
            background-color: var(--dark-square);
        }

        /* 5. [수정] 게임 말 (이모지 크기 80px칸에 맞춤) */
        .piece {
            width: 75%;
            height: 75%;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            
            /* [수정] 이모지 크기 축소 (48px -> 42px) */
            font-size: 42px;
            line-height: 1;
            
            background-color: transparent;
            transition: all 0.2s ease;
            position: relative;
        }

        .player-1::before {
            content: '🐱';
            text-shadow: 0 0 3px rgba(0,0,0,0.3);
        }

        .player-2::before {
            content: '🐶'; /* 강아지 */
            text-shadow: 0 0 3px rgba(0,0,0,0.3);
            /* [추가] AI 말은 클릭 불가 스타일 (커서 변경) */
            cursor: default;
        }
        
        /* 6. [수정] 킹(King) 말 왕관 스타일 (위치 조정) */
        .king::after {
            content: '👑';
            position: absolute;
            font-size: 0.7em;
            line-height: 1;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            
            /* [수정] 작아진 이모지 머리 위로 (3px -> 2px) */
            top: 2px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* 7. 선택된 칸 하이라이트 */
        .square.selected .player-1 {
            transform: scale(1.1);
        }
        .square.selected .player-1::before {
            text-shadow: 0 0 8px var(--highlight-p1-glow), 0 0 12px var(--highlight-p1-glow);
        }
        /* AI 말은 선택되면 안되지만 혹시 모를 상황 대비 */
        .square.selected .player-2 {
            transform: scale(1.1);
        }
        .square.selected .player-2::before {
             text-shadow: 0 0 8px var(--highlight-p2-glow), 0 0 12px var(--highlight-p2-glow);
        }
        
        /* 8. [수정] 이동 가능 칸 하이라이트 (점 크기 축소) */
        .square.can-move::after {
            content: '';
            position: absolute;
            width: 16px; /* [수정] 1.5배 (18px -> 16px) */
            height: 16px; /* [수정] 1.5배 (18px -> 16px) */
            background: var(--highlight-move);
            border-radius: 50%;
            opacity: 0.8;
            animation: pulse-dot 1.5s infinite ease-in-out;
        }
        .square.can-move:hover {
            background-color: #eef2f7;
        }
        
        .square.mandatory-jump .piece {
            animation: pulse-scale 1s infinite ease-in-out;
        }

        /* 10. 버튼 스타일 (큼직하게 유지) */
        button {
            padding: 18px 38px;
            font-size: 1.6em;
            font-weight: 700;
            font-family: 'Nunito', sans-serif;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            margin-top: 38px;
            background-color: var(--player-1);
            color: white;
            transition: all 0.2s ease;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
        }
        button:hover {
            background-color: #ff6363;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }
        
        /* 11. 애니메이션 정의 */
        @keyframes pulse-dot {
            0%, 100% { transform: scale(0.8); opacity: 0.5; }
            50% { transform: scale(1); opacity: 0.8; }
        }
        @keyframes pulse-scale {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.08); }
        }

        /* 12. [수정] 스코어보드 스타일 (위치 변경) */
        .scoreboard {
            width: 300px;
            padding: 25px;
            background-color: var(--light-square);
            border: 5px solid var(--text-dark);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1), 0 4px 8px rgba(0, 0, 0, 0.05);
            
            /* [수정] 오른쪽-중간 정렬을 위해 align-self 사용 */
            align-self: center;
            /* [삭제] margin-top: 33px; */
        }

        .scoreboard h3 {
            text-align: center;
            margin-top: 0;
            margin-bottom: 30px;
            font-size: 2.0em;
        }

        .score-item {
            display: flex;
            align-items: center;
            margin-bottom: 25px;
            font-size: 1.5em;
        }
        .score-item .icon {
            font-size: 1.8em;
            margin-right: 15px;
        }
        .score-item .label {
            font-weight: 700;
        }
        .score-item .count {
            font-size: 2.0em;
            font-weight: 900;
            margin-left: auto; /* 숫자를 오른쪽으로 밀기 */
            color: var(--player-1);
        }
        .score-item:last-child .count {
            color: var(--player-2);
        }

    </style>
</head>
<body>
    
    <div class="game-container">
        <h1>💖 AI와 체커 대결! 💖</h1>
        
        <div id="status-message">게임을 시작하세요! 당신은 고양이(🐱)입니다.</div>

        <div class="board" id="board">
            </div>
        
        <button id="reset-button">새 게임 시작</button>
    </div>

    <div class="scoreboard">
        <h3>전적 🏆</h3>
        <div class="score-item">
            <span class="icon">🐱</span>
            <span class="label">내가 잡음:</span>
            <span class="count" id="p1-score">0</span>
        </div>
        <div class="score-item">
            <span class="icon">🐶</span>
            <span class="label">AI가 잡음:</span>
            <span class="count" id="p2-score">0</span>
        </div>
    </div>


    <script>
        // --- DOM 요소 정의 (스코어보드 포함) ---
        const boardEl = document.getElementById('board');
        const statusMessageEl = document.getElementById('status-message');
        const resetButton = document.getElementById('reset-button');
        const p1ScoreEl = document.getElementById('p1-score');
        const p2ScoreEl = document.getElementById('p2-score');
        
        const PLAYER_1 = 1; // 사용자 (고양이)
        const PLAYER_2 = 2; // 컴퓨터 (강아지)
        
        // [삭제] 킹 방향 정의 삭제 (규칙 2 변경으로 불필요)
        // const KING_DIR_DOWN = 1;
        // const KING_DIR_UP = 2;  

        // --- 게임 상태 변수 (스코어 포함) ---
        let boardState = [];      
        let currentPlayer = PLAYER_1;
        let isGameActive = true;    
        let selectedPiece = null;  
        let mandatoryJump = [];    
        let p1Score = 0; // 사용자(P1)가 잡은 말 수
        let p2Score = 0; // 컴퓨터(P2)가 잡은 말 수 (AI가 잡은 말 수)
        
        // [추가] 왕 한정 승격 규칙을 위한 플래그 (규칙 1)
        let firstKingMade = {
            [PLAYER_1]: false, // 사용자 (고양이)의 왕 탄생 여부
            [PLAYER_2]: false  // AI (강아지)의 왕 탄생 여부
        };

        // --- 초기화 함수 ---
        
        function initBoard() {
            /*
                [규칙 3, 2] 말의 가치(Value) 정의
                0: 빈 칸
                1: P1 (고양이) 일반 말 (앞으로만 이동)
                2: P2 (강아지) 일반 말 (앞으로만 이동)
               11: P1 승격 실패 말 (앞/뒤 이동 가능)
               12: P2 승격 실패 말 (앞/뒤 이동 가능)
               21: P1 킹 (4방향 무제한 이동/점프)
               22: P2 킹 (4방향 무제한 이동/점프)
            */
            boardState = Array(8).fill(0).map(() => Array(8).fill(0));
            boardEl.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    if ((row < 3) && (row + col) % 2 !== 0) {
                        boardState[row][col] = PLAYER_2;
                    } else if ((row > 4) && (row + col) % 2 !== 0) {
                        boardState[row][col] = PLAYER_1;
                    }
                    
                    const squareEl = document.createElement('div');
                    squareEl.className = 'square ' + (((row + col) % 2 === 0) ? 'light' : 'dark');
                    squareEl.dataset.row = row;
                    squareEl.dataset.col = col;
                    boardEl.appendChild(squareEl);
                }
            }
            
            updateBoardDisplay();
            resetButton.addEventListener('click', resetGame);
            statusMessageEl.textContent = "당신의 턴입니다 (🐱).";
            isGameActive = true;
            currentPlayer = PLAYER_1;
            selectedPiece = null;
            mandatoryJump = [];
            
            p1Score = 0;
            p2Score = 0;
            updateScoreDisplay();
            
            // 왕 한정 승격 플래그 초기화
            firstKingMade = { [PLAYER_1]: false, [PLAYER_2]: false };
        }

        // 스코어보드 화면 업데이트 함수
        function updateScoreDisplay() {
            p1ScoreEl.textContent = p1Score;
            p2ScoreEl.textContent = p2Score;
        }

        // --- 화면 업데이트 함수 ---

        function updateBoardDisplay() {
            const squares = boardEl.querySelectorAll('.square');
            squares.forEach(square => {
                const row = parseInt(square.dataset.row);
                const col = parseInt(square.dataset.col);
                const pieceValue = boardState[row][col];
                
                square.innerHTML = '';
                square.classList.remove('selected', 'can-move', 'mandatory-jump');

                if (pieceValue !== 0) {
                    const pieceEl = document.createElement('div');
                    // [수정] 킹 판정 기준 변경: 20 이상이면 킹 (21, 22)
                    const isKing = pieceValue >= 20;
                    // 플레이어는 10의 나머지 (1, 2, 11, 12 모두 1 또는 2)
                    const player = pieceValue % 10;
                    
                    pieceEl.className = `piece player-${player} ${isKing ? 'king' : ''}`;
                    pieceEl.dataset.player = player;
                    
                    // 플레이어 1 (사용자)의 말만 클릭 이벤트 등록
                    if (player === PLAYER_1 && isGameActive) {
                        pieceEl.addEventListener('click', handlePieceClick);
                    }
                    
                    square.appendChild(pieceEl);
                }
                
                square.removeEventListener('click', handleSquareClick);
                // 일반 이동은 PLAYER_1의 턴일 때만 처리 (handleSquareClick에서 턴 체크)
                if (pieceValue === 0) {
                     square.addEventListener('click', handleSquareClick);
                }
            });
            
            mandatoryJump = findMandatoryJumps(currentPlayer);
            
            // 턴 메시지/점프 메시지 표시 로직
            const isTurnMessage = statusMessageEl.textContent.includes('턴입니다');
            if (mandatoryJump.length > 0) {
                if (isTurnMessage) {
                     statusMessageEl.innerHTML = "상대 말을 잡는 점프는 <strong>필수</strong>입니다!";
                }
                // (연속 점프 메시지는 movePiece에서 처리)
                highlightMandatoryJumps();
            } else if (!isTurnMessage) {
                 // 점프 메시지가 떠 있었는데 점프가 끝나면 턴 메시지로 복구
                 if (currentPlayer === PLAYER_1) {
                    statusMessageEl.textContent = "당신의 턴입니다 (🐱).";
                 } else {
                    statusMessageEl.textContent = "AI의 턴입니다 (🐶).";
                 }
            }
        }

        // --- 이벤트 핸들러 ---
        
        function handlePieceClick(event) {
            event.stopPropagation();
            
            const pieceEl = event.target.closest('.piece');
            if (!pieceEl) return;
            
            const squareEl = pieceEl.parentElement;
            const row = parseInt(squareEl.dataset.row);
            const col = parseInt(squareEl.dataset.col);
            
            // 내 턴, 내 말인지 확인
            if (boardState[row][col] % 10 !== PLAYER_1 || currentPlayer !== PLAYER_1) return;

            clearHighlights();
            
            selectedPiece = [row, col];
            squareEl.classList.add('selected');
            
            highlightPossibleMoves(row, col);
        }

        function handleSquareClick(event) {
            if (!isGameActive || currentPlayer !== PLAYER_1 || !selectedPiece) return;
            
            const squareEl = event.currentTarget;
            const targetRow = parseInt(squareEl.dataset.row);
            const targetCol = parseInt(squareEl.dataset.col);
            
            if (squareEl.classList.contains('can-move')) {
                movePiece(selectedPiece[0], selectedPiece[1], targetRow, targetCol);
            }
        }
        
        // --- 이동 및 승패 판정 로직 (스코어 계산) ---

        function movePiece(fromRow, fromCol, toRow, toCol) {
            
            let capturedRow, capturedCol;
            const pieceValue = boardState[fromRow][fromCol];
            const player = pieceValue % 10;
            // [수정] 킹 판정 기준 변경
            const isKing = pieceValue >= 20;

            // 점프 여부 및 잡은 말 위치 확인
            if (Math.abs(fromRow - toRow) > 1) {
                const possibleMoves = findPossibleMoves(fromRow, fromCol)
                    .filter(m => m.isJump && m.row === toRow && m.col === toCol);
                
                if (possibleMoves.length > 0 && possibleMoves[0].capturedRow !== undefined) {
                    capturedRow = possibleMoves[0].capturedRow;
                    capturedCol = possibleMoves[0].capturedCol;
                } else if (Math.abs(fromRow - toRow) === 2 && !isKing) {
                    // (킹이 아닌) 일반 말의 한 칸 점프
                    capturedRow = (fromRow + toRow) / 2;
                    capturedCol = (fromCol + toCol) / 2;
                } else {
                    // 이 경로는 킹의 '비행 점프'가 아닌 단순 '비행 이동'일 때 발생 가능
                    // (findPossibleMoves가 점프만 반환하므로 사실상 이 else는 거의 도달 안 함)
                    // return; 
                }
            }

            if (capturedRow !== undefined) {
                const capturedPieceValue = boardState[capturedRow][capturedCol];
                
                if (capturedPieceValue % 10 === PLAYER_2) {
                    p1Score++;
                } else if (capturedPieceValue % 10 === PLAYER_1) {
                    p2Score++;
                }
                
                updateScoreDisplay();
                boardState[capturedRow][capturedCol] = 0; // 잡은 말 제거
            }

            boardState[toRow][toCol] = boardState[fromRow][fromCol];
            boardState[fromRow][fromCol] = 0;

            // [규칙 1 & 3 수정] 킹 만들기: 해당 플레이어의 첫 번째 말만 왕(21/22)이 됨.
            const promotionRow = (player === PLAYER_1) ? 0 : 7;
            // pieceValue < 20 : 킹이 아닌 말 (1, 2, 11, 12)이 도달했는지
            const isPromoted = (toRow === promotionRow) && (pieceValue < 20);
            
            if (isPromoted) {
                 if (!firstKingMade[player]) {
                    // 규칙 1: 최초 1회 왕 승격
                    let kingValue = (player === PLAYER_1) ? 21 : 22;
                    boardState[toRow][toCol] = kingValue; // 킹으로 승격
                    firstKingMade[player] = true; // 플래그 설정
                 } else {
                    // ★[규칙 3 적용]★
                    // 이미 왕이 탄생했으면, '뒤로 가는 일반 말' (11 또는 12)로 변경
                    boardState[toRow][toCol] = (player === PLAYER_1) ? 11 : 12;
                 }
            }
            
            clearHighlights();
            selectedPiece = null;
            
            // ★[규칙 4 수정]★
            // 연속 점프는 방금 점프를 수행한 말만 계속해야 함 (AI 로직 추가)
            if (capturedRow !== undefined) {
                const nextJumps = findJumpsFromLocation(toRow, toCol);
                
                if (nextJumps.length > 0) {
                    selectedPiece = [toRow, toCol]; // 다음 점프를 위해 말 선택 고정
                    mandatoryJump = [[toRow, toCol]]; // 강제 점프 말 설정
                    
                    if (player === PLAYER_1) {
                        // 사용자 턴: 하이라이트 갱신
                        const newSquareEl = boardEl.querySelector(`[data-row="${toRow}"][data-col="${toCol}"]`);
                        newSquareEl.classList.add('selected');
                        highlightPossibleMoves(toRow, toCol, true);
                        updateBoardDisplay();
                        highlightMandatoryJumps();
                        statusMessageEl.innerHTML = "연속 점프가 <strong>필수</strong>입니다!";
                    } else if (player === PLAYER_2) {
                        // AI 턴: 상태 메시지 변경 및 다음 AI 이동 예약
                        statusMessageEl.innerHTML = "AI가 <strong>연속 점프</strong>합니다!";
                        updateBoardDisplay(); // 말 잡힌 것 표시
                        setTimeout(aiMove, 1000); // 다음 점프를 위해 aiMove 다시 호출
                    }
                    
                    return; // 턴 전환을 하지 않음
                }
            }

            switchPlayer();
            checkWin();
        }

        function switchPlayer() {
            currentPlayer = (currentPlayer === PLAYER_1) ? PLAYER_2 : PLAYER_1;
            statusMessageEl.textContent = (currentPlayer === PLAYER_1) ? "당신의 턴입니다 (🐱)." : "AI의 턴입니다 (🐶).";
            updateBoardDisplay();
            
            if (currentPlayer === PLAYER_2 && isGameActive) {
                // AI 턴일 때 1초 지연 후 aiMove 호출
                setTimeout(aiMove, 1000);
            }
        }
        
        function checkWin() {
            if (p1Score === 12) {
                isGameActive = false;
                statusMessageEl.textContent = "사용자 승리! 🎉";
                return;
            } else if (p2Score === 12) {
                isGameActive = false;
                statusMessageEl.textContent = "AI 승리! 😭";
                return;
            }
            
            if (isGameActive) {
                let canMove = false;
                
                if (findMandatoryJumps(currentPlayer).length > 0) {
                    canMove = true;
                } else {
                    for (let row = 0; row < 8; row++) {
                        for (let col = 0; col < 8; col++) {
                            // 킹(21,22), 승격실패말(11,12)도 이동 가능성 확인에 포함
                            if (boardState[row][col] % 10 === currentPlayer && boardState[row][col] !== 0) {
                                // 일반 이동(isJump: false)이 있는지 확인
                                if (findPossibleMoves(row, col).some(m => !m.isJump)) {
                                    canMove = true;
                                    break;
                                }
                            }
                        }
                        if(canMove) break;
                    }
                }

                if (!canMove) {
                    isGameActive = false;
                    if (currentPlayer === PLAYER_1) {
                        statusMessageEl.textContent = "움직일 곳이 없어요... AI 승리! 😭";
                    } else {
                        statusMessageEl.textContent = "AI가 움직일 곳이 없네요. 사용자 승리! 🎉";
                    }
                }
            }
        }

        // --- 유틸리티 및 하이라이트 함수 ---
        
        function clearHighlights() {
            boardEl.querySelectorAll('.selected, .can-move, .mandatory-jump').forEach(el => {
                el.classList.remove('selected', 'can-move', 'mandatory-jump');
            });
        }
        
        function highlightMandatoryJumps() {
            mandatoryJump.forEach(loc => {
                const squareEl = boardEl.querySelector(`[data-row="${loc[0]}"][data-col="${loc[1]}"]`);
                if (squareEl) squareEl.classList.add('mandatory-jump');
            });
        }
        
        function highlightPossibleMoves(row, col, jumpOnly = false) {
            const possibleMoves = findPossibleMoves(row, col);

            const isMandatory = mandatoryJump.length > 0;
            // 강제 점프 말만 선택 가능하도록 로직 유지 (규칙 4 준수)
            if (isMandatory && !mandatoryJump.some(loc => loc[0] === row && loc[1] === col)) {
                return;
            }
            
            possibleMoves.forEach(move => {
                if (isMandatory) {
                    if (move.isJump) {
                         const squareEl = boardEl.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
                         squareEl.classList.add('can-move');
                    }
                } else {
                    if (!jumpOnly || move.isJump) {
                         const squareEl = boardEl.querySelector(`[data-row="${move.row}"][data-col="${move.col}"]`);
                         squareEl.classList.add('can-move');
                    }
                }
            });
        }
        
        // --- ★[규칙 2, 3] 이동 가능 위치 찾기 (핵심 수정)★ ---

        function findPossibleMoves(row, col) {
            const pieceValue = boardState[row][col];
            if (pieceValue === 0) return [];
            
            const player = pieceValue % 10;
            const isKing = pieceValue >= 20; // 킹 판정 (21, 22)
            const moves = [];
            let jumpMoves = [];
            
            const directions = [];
            
            // ★[규칙 2 적용]★
            if (isKing) {
                // 킹은 4방향 대각선 이동
                directions.push(
                    { row: -1, col: -1 }, // 위-왼쪽
                    { row: -1, col: 1 },  // 위-오른쪽
                    { row: 1, col: -1 },  // 아래-왼쪽
                    { row: 1, col: 1 }   // 아래-오른쪽
                );
            } 
            // ★[규칙 3 적용]★
            else {
                // 규칙 3: 승격 실패 말(11, 12) / 일반 말(1, 2) 판정
                const isUpgradedRegular = (pieceValue === 11 || pieceValue === 12);
                
                // 일반 말의 '앞' 방향 (P1: -1, P2: 1)
                const forwardDir = (player === PLAYER_1) ? -1 : 1;
                directions.push({ row: forwardDir, col: -1 }, { row: forwardDir, col: 1 });

                // 규칙 3 적용: 승격 실패한 말(11, 12)은 '뒤'로도 이동 가능
                if (isUpgradedRegular) {
                    const backwardDir = -forwardDir;
                    directions.push({ row: backwardDir, col: -1 }, { row: backwardDir, col: 1 });
                }
            }
            
            for (const dir of directions) {
                let r = row + dir.row;
                let c = col + dir.col;
                let pieceEncountered = null; // 경로에서 만난 '상대 말'의 위치

                while (isValid(r, c)) {
                    // 1. 빈 칸
                    if (boardState[r][c] === 0) {
                        if (pieceEncountered === null) {
                            // A. (점프 아님) 말을 만나기 전 빈 칸
                            moves.push({ row: r, col: c, isJump: false });
                            
                            // 킹이 아니면 한 칸만 이동 가능
                            if (!isKing) break; 
                            
                        } else {
                            // B. (점프 도착지) 상대 말을 만난 후 빈 칸 (킹의 Flying Jump)
                            jumpMoves.push({
                                row: r, col: c, isJump: true,
                                capturedRow: pieceEncountered.row,
                                capturedCol: pieceEncountered.col
                            });
                            
                            // 일반 말은 점프 도착지가 한 칸으로 고정됨
                            if (!isKing) break;
                        }
                    }
                    // 2. 말이 있는 칸
                    else {
                        const encounteredPlayer = boardState[r][c] % 10;
                        
                        if (encounteredPlayer === player) {
                            // C. 아군 말을 만남 -> 막힘
                            break;
                        } else {
                            // D. 상대방 말을 만남
                            if (pieceEncountered === null) {
                                // D-1. 경로에서 첫 번째 상대 말을 만남
                                pieceEncountered = { row: r, col: c };
                                
                                if (!isKing) {
                                    // 일반 말 점프 로직 (바로 다음 칸 확인)
                                    const jumpRow = r + dir.row;
                                    const jumpCol = c + dir.col;
                                    if (isValid(jumpRow, jumpCol) && boardState[jumpRow][jumpCol] === 0) {
                                        jumpMoves.push({
                                            row: jumpRow, col: jumpCol, isJump: true,
                                            capturedRow: r,
                                            capturedCol: c
                                        });
                                    }
                                    break; // 일반 말은 점프 후 탐색 종료
                                }
                                // 킹은 점프 후 다음 칸부터 다시 탐색해야 함 (D-2로 이어짐)

                            } else {
                                // D-2. 두 번째 상대 말을 만남 (킹의 비행 점프 경로 막힘)
                                break;
                            }
                        }
                    }
                    
                    // 다음 칸으로 이동 (킹 또는 일반 말의 점프 확인)
                    r += dir.row;
                    c += dir.col;
                }
            }
            
            // 점프가 있으면 점프만 반환 (규칙 4)
            if (jumpMoves.length > 0) {
                 return jumpMoves;
            }
            
            // 강제 점프가 '있는' 상황인데 '이 말'은 점프가 안되면, 일반 이동도 막아야 함 (규칙 4)
            if (mandatoryJump.length > 0) {
                 return [];
            }

            // 점프가 없을 때만 일반 이동 반환
            return moves;
        }

        function findJumpsFromLocation(row, col) {
             return findPossibleMoves(row, col).filter(m => m.isJump);
        }
        
        function findMandatoryJumps(player) {
            const jumpPieces = [];
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const pieceValue = boardState[row][col];
                    // 킹(21,22), 승격실패말(11,12)도 포함하여 현재 플레이어의 말을 찾음
                    if (pieceValue % 10 === player && pieceValue !== 0) {
                        if (findPossibleMoves(row, col).some(m => m.isJump)) {
                            jumpPieces.push([row, col]);
                        }
                    }
                }
            }
            return jumpPieces;
        }

        function isValid(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }
        
        // --- AI (컴퓨터) 로직 ---

        function aiMove() {
            if (!isGameActive || currentPlayer !== PLAYER_2) return;

            let allPossibleMoves = [];
            
            // [규칙 4] 1. 현재 턴이 연속 점프 중인지 확인
            // (movePiece에서 selectedPiece와 mandatoryJump를 설정해줌)
            const isContinuingJump = mandatoryJump.length > 0 && selectedPiece !== null;

            // 1a. 강제 점프 확인 (연속 점프 상태 포함)
            const mandatoryJumps = isContinuingJump ? [selectedPiece] : findMandatoryJumps(PLAYER_2);
            
            if (mandatoryJumps.length > 0) {
                // 연속 점프 중일 때, selectedPiece로 이동할 수 있는 점프만 찾음
                mandatoryJumps.forEach(loc => {
                    // 점프만 필터링
                    const moves = findPossibleMoves(loc[0], loc[1]).filter(m => m.isJump);
                    moves.forEach(move => {
                        allPossibleMoves.push({ from: loc, to: move });
                    });
                });
            }
            // 1b. 강제 점프 없으면 일반 이동 (연속 점프 상태가 아닐 때만 실행)
            else if (!isContinuingJump) {
                for (let row = 0; row < 8; row++) {
                    for (let col = 0; col < 8; col++) {
                        // 킹(21,22), 승격실패말(11,12)도 포함하여 현재 플레이어의 말을 찾음
                        if (boardState[row][col] % 10 === PLAYER_2 && boardState[row][col] !== 0) {
                            // 일반 이동만 필터링
                            const moves = findPossibleMoves(row, col).filter(m => !m.isJump);
                            if (moves.length > 0) {
                                moves.forEach(move => {
                                    allPossibleMoves.push({ from: [row, col], to: move });
                                });
                            }
                        }
                    }
                }
            }
            
            // 2. 움직일 수 없으면 (checkWin이 이미 처리함)
            if (allPossibleMoves.length === 0) {
                 return;
            }

            // 3. 가능한 모든 이동 중 하나를 무작위로 선택
            const chosenMove = allPossibleMoves[Math.floor(Math.random() * allPossibleMoves.length)];
            
            // [삭제] 4. 연속 점프 시 selectedPiece 설정 (movePiece에서 처리하므로 중복)
            // if (isContinuingJump) { ... }

            // 5. 움직임 실행
            movePiece(chosenMove.from[0], chosenMove.from[1], chosenMove.to.row, chosenMove.to.col);
        }

        function resetGame() {
            initBoard();
        }

        // --- 게임 시작 ---
        initBoard();
    </script>
</body>
</html>